// index.js (ESM)
import express from "express";
import cors from "cors";
import dotenv from "dotenv";
import OpenAI from "openai";

dotenv.config();

const app = express();
const port = process.env.PORT || 3000;

/* ===========================
   CORSË®≠ÂÆöÔºàÊú¨Áï™Áí∞Â¢ÉÁî®Ôºâ
=========================== */
const corsOptions = {
  origin: process.env.ALLOWED_ORIGINS 
    ? process.env.ALLOWED_ORIGINS.split(',') 
    : '*',
  methods: ['GET', 'POST'],
  credentials: true
};
app.use(cors(corsOptions));
app.use(express.json({ limit: '1mb' }));

// ‚úÖ static „ÅØ1Âõû„Å†„Åë„ÄÇ/ „Åß home.html „ÇíËøî„Åó„Åü„ÅÑ„ÅÆ„Åß index:false
app.use(express.static("public", { index: false }));

/* ---------- „Éõ„Éº„É† & „Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà ---------- */
app.get("/", (_req, res) => {
  res.sendFile("home.html", { root: "public" }, (err) => {
    if (err) res.sendFile("index.html", { root: "public" });
  });
});
app.get("/menu", (_req, res) => res.sendFile("index.html", { root: "public" }));
app.get("/recipe", (_req, res) => res.sendFile("recipe.html", { root: "public" }));

/* ===========================
   OpenAIÂàùÊúüÂåñ
=========================== */
if (!process.env.OPENAI_API_KEY) {
  console.error("‚ö†Ô∏è OPENAI_API_KEY is missing.");
  process.exit(1);
}
const client = new OpenAI({ 
  apiKey: process.env.OPENAI_API_KEY,
  timeout: 60000,
  maxRetries: 2
});

/* ===========================
   È£üÊùê„Ç∞„É´„Éº„Éó„Å®„Ç®„Ç§„É™„Ç¢„Çπ
=========================== */
const ingredientCategories = {
  vegetables: {
    "„Ç≠„É£„Éô„ÉÑ": ["ÁôΩËèú","„É¨„Çø„Çπ","Â∞èÊùæËèú","„Åª„ÅÜ„Çå„ÇìËçâ","„ÉÅ„É≥„Ç≤„É≥Ëèú","Ê∞¥Ëèú"],
    "ÁôΩËèú": ["„Ç≠„É£„Éô„ÉÑ","„É¨„Çø„Çπ","Â∞èÊùæËèú","„Åª„ÅÜ„Çå„ÇìËçâ","„ÉÅ„É≥„Ç≤„É≥Ëèú"],
    "„Å´„Çì„Åò„Çì": ["Â§ßÊ†π","„Åã„Å∂","„Åã„Åº„Å°„ÇÉ","„Éë„Éó„É™„Ç´"],
    "„Åò„ÇÉ„Åå„ÅÑ„ÇÇ": ["„Åï„Å§„Åæ„ÅÑ„ÇÇ","Èï∑Ëäã","„Åã„Åº„Å°„ÇÉ"],
    "Áéâ„Å≠„Åé": ["Èï∑„Å≠„Åé","„Éã„É©","„Ç®„Ç∑„É£„É≠„ÉÉ„Éà"],
    "„Éñ„É≠„ÉÉ„Ç≥„É™„Éº": ["„Ç´„É™„Éï„É©„ÉØ„Éº","„Çπ„Éä„ÉÉ„Éó„Ç®„É≥„Éâ„Ç¶","„Ç¢„Çπ„Éë„É©„Ç¨„Çπ"],
    "„Éî„Éº„Éû„É≥": ["„Éë„Éó„É™„Ç´","„Ç∫„ÉÉ„Ç≠„Éº„Éã","„Å™„Åô"],
  },
  meats: {
    "È∂èËÇâ": ["Ë±öËÇâ","ÁâõËÇâ","„Å≤„ÅçËÇâ"],
    "Ë±öËÇâ": ["È∂èËÇâ","ÁâõËÇâ","„Å≤„ÅçËÇâ"],
    "ÁâõËÇâ": ["È∂èËÇâ","Ë±öËÇâ","„Å≤„ÅçËÇâ"],
    "„Å≤„ÅçËÇâ": ["È∂èËÇâ","Ë±öËÇâ","ÁâõËÇâ"],
  },
  fish: {
    "ÈÆ≠": ["ÈØñ","„Çø„É©","„Çµ„ÉØ„É©"],
    "ÈØñ": ["ÈÆ≠","„Çø„É©","„Çµ„ÉØ„É©"],
    "„Çø„É©": ["ÈÆ≠","ÈØñ","„Çµ„ÉØ„É©"],
    "„Çµ„ÉØ„É©": ["ÈÆ≠","ÈØñ","„Çø„É©"],
  },
  protein: {
    "Âçµ": ["Ë±ÜËÖê","ÂéöÊèö„Åí","Ê≤πÊèö„Åí"],
    "Ë±ÜËÖê": ["ÂéöÊèö„Åí","Ê≤πÊèö„Åí","Âçµ"],
    "ÂéöÊèö„Åí": ["Ë±ÜËÖê","Ê≤πÊèö„Åí","Âçµ"],
  },
};

const stapleFoods = [
  "„ÅîÈ£Ø","ÁôΩÁ±≥","ÁéÑÁ±≥","„É©„Ç§„Çπ",
  "„Éë„É≥","È£ü„Éë„É≥","„Éà„Éº„Çπ„Éà","„Çµ„É≥„Éâ„Ç§„ÉÉ„ÉÅ","„Éõ„ÉÉ„Éà„Çµ„É≥„Éâ",
  "„ÅÜ„Å©„Çì","„Åù„Å∞","„Åù„ÅÜ„ÇÅ„Çì","„Éë„Çπ„Çø","„Çπ„Éë„Ç≤„ÉÉ„ÉÜ„Ç£","„É©„Éº„É°„É≥","‰∏≠ËèØÈ∫∫",
  "„Åä„Å´„Åé„Çä","„ÉÅ„É£„Éº„Éè„É≥","ÁÑº„Åç„Åù„Å∞","„Ç∞„É©„Éé„Éº„É©"
];

const cookWordRe = /(ÁÑº|ÁÇí|ÁÖÆ|Ëí∏|Êèö|Âíå„Åà|Êº¨|Ëåπ|ÁÇä|Ê∑∑|„Å®„Åò|„Ç™„É†„É¨„ÉÑ|„Ç∞„É©„Çø„É≥|„Ç´„É¨„Éº|„ÉÅ„É£„Éº„Éè„É≥|‰∏º|ÂÆöÈ£ü|„Çµ„É≥„Éâ|„Éà„Éº„Çπ„Éà|„Éë„Çπ„Çø|„Çπ„Éë„Ç≤|„ÅÜ„Å©„Çì|„Åù„Å∞|„É©„Éº„É°„É≥|Á≤•|ÈõëÁÇä|„Åä„Å´„Åé„Çä|Âë≥ÂôåÊ±Å|„Çπ„Éº„Éó)/;

const aliases = {
  "È∂è": "È∂èËÇâ",
  "Ë±ö": "Ë±öËÇâ",
  "Áâõ": "ÁâõËÇâ",
  "„Çµ„Éº„É¢„É≥": "ÈÆ≠",
  "„Åï„Å∞": "ÈØñ",
  "„Çµ„Éê": "ÈØñ",
  "„ÉÑ„Éä": "„ÉÑ„Éä",
};
const canon = (t = "") => aliases[t] || t;

/* ===========================
   „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£
=========================== */
const normalize = (s) =>
  String(s || "").trim().toLowerCase().replace(/\s+/g, "").replace(/[ÔºàÔºâ()„ÄÄ]/g, "");

function extractFirstJson(text) {
  text = String(text || "").trim();
  text = text.replace(/```(?:json)?\s*/g, "").replace(/```\s*/g, "");
  
  let depth = 0;
  let start = -1;
  let end = -1;
  
  for (let i = 0; i < text.length; i++) {
    if (text[i] === '{') {
      if (depth === 0) start = i;
      depth++;
    } else if (text[i] === '}') {
      depth--;
      if (depth === 0 && start >= 0) {
        end = i;
        break;
      }
    }
  }
  
  if (start >= 0 && end > start) {
    return text.slice(start, end + 1);
  }
  
  const i = text.indexOf("{");
  const j = text.lastIndexOf("}");
  return (i >= 0 && j > i) ? text.slice(i, j + 1) : text;
}

async function callModel(prompt, { temperature = 0.7, maxRetries = 3 } = {}) {
  let lastError;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`üîÑ OpenAI API call (attempt ${attempt}/${maxRetries})`);
      
      const r = await client.chat.completions.create({
        model: "gpt-4o",
        messages: [{ role: "user", content: prompt }],
        temperature,
        top_p: 0.95,
        presence_penalty: 0.2,
        frequency_penalty: 0.2
      });
      
      const content = r.choices?.[0]?.message?.content ?? "";
      
      if (!content) {
        throw new Error("Empty response from OpenAI");
      }
      
      console.log(`‚úÖ OpenAI API success (${content.length} chars)`);
      return content;
      
    } catch (error) {
      lastError = error;
      console.error(`‚ùå OpenAI API error (attempt ${attempt}):`, error.message);
      
      if (error?.status === 429) {
        const waitTime = Math.min(2000 * attempt, 10000);
        console.log(`‚è≥ Rate limited, waiting ${waitTime}ms...`);
        await new Promise(resolve => setTimeout(resolve, waitTime));
        continue;
      }
      
      if (error?.code === 'ETIMEDOUT' || error?.code === 'ECONNRESET') {
        console.log(`‚è≥ Network error, retrying...`);
        await new Promise(resolve => setTimeout(resolve, 1000));
        continue;
      }
      
      if (attempt === maxRetries) {
        throw error;
      }
    }
  }
  
  throw lastError || new Error("OpenAI API call failed after retries");
}

const isGenericName = (name = "") => {
  const n = String(name).trim();
  return !!n && /^[^\s]+$/.test(n) && !cookWordRe.test(n);
};

const escapeReg = (s) => String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

function sanitizeMeal(name = "", mealType = "") {
  let n = String(name || "").replace(/\s+/g, " ").trim();
  
  if (!n) return "";

  const badSoup = /(„Ç™„É†„É¨„ÉÑ|„Éë„É≥„Ç±„Éº„Ç≠|„É®„Éº„Ç∞„É´„Éà|„Ç±„Éº„Ç≠|„Éó„É™„É≥|„Éë„Éï„Çß|„Çµ„É≥„Éâ|‰∏º|ÂÆöÈ£ü)/;
  if (/(Âë≥ÂôåÊ±Å|„Çπ„Éº„Éó)/.test(n) && badSoup.test(n)) {
    n = "Ë±ÜËÖê„Å®„Çè„Åã„ÇÅ„ÅÆÂë≥ÂôåÊ±Å";
  }
  
  if (/Âçµ„Å®„Åò/.test(n) && /(„É®„Éº„Ç∞„É´„Éà|„Éï„É´„Éº„ÉÑ|„Éë„É≥„Ç±„Éº„Ç≠)/.test(n)) {
    n = "„Åª„ÅÜ„Çå„ÇìËçâ„ÅÆÂçµ„Å®„Åò";
  }

  if (mealType === "ÊòºÈ£ü") {
    const hasStaple = /(„ÅîÈ£Ø|„É©„Ç§„Çπ|‰∏º|„Éë„É≥|„Çµ„É≥„Éâ|„Éà„Éº„Çπ„Éà|„ÅÜ„Å©„Çì|„Åù„Å∞|„Åù„ÅÜ„ÇÅ„Çì|„Éë„Çπ„Çø|„Çπ„Éë„Ç≤„ÉÉ„ÉÜ„Ç£|„Çπ„Éë„Ç≤„ÉÜ„Ç£|„É©„Éº„É°„É≥|ÁÑº„Åç„Åù„Å∞|„ÉÅ„É£„Éº„Éè„É≥|È∫∫)/.test(n);
    if (!hasStaple) {
      n = `${n}„Å®„ÅîÈ£Ø`;
    }
  }

  if (mealType === "Â§ïÈ£ü") {
    const hasProtein = /(È∂è|Ë±ö|Áâõ|ÈÆ≠|ÈØñ|„Çø„É©|„Çµ„ÉØ„É©|È≠ö|Âçµ|Ë±ÜËÖê|ÂéöÊèö„Åí|„ÉÑ„Éä)/.test(n);
    if (!hasProtein) {
      n = `${n}„Å®È∂è„ÅÆÁÖß„ÇäÁÑº„Åç`;
    }
  }

  if (mealType === "ÊúùÈ£ü") {
    if (/^[^\s]+$/.test(n) && !/(Ê±Å|„Çπ„Éº„Éó|‰∏º|„Çµ„É≥„Éâ|„Éà„Éº„Çπ„Éà|Á≤•|ÈõëÁÇä)/.test(n)) {
      n = `${n}„ÅÆÂçµ„Å®„Åò`;
    }
  }

  n = n.replace(/(ÈÆ≠|ÈØñ|„Çø„É©|„Çµ„ÉØ„É©)„ÅÆÊ≤πÊèö„Åí/g, "$1„ÅÆÂ°©ÁÑº„Åç");
  n = n.replace(/(„Çπ„Éë„Ç≤(?:„ÉÉ„ÉÜ„Ç£|„ÉÜ„Ç£)?|„Éë„Çπ„Çø)[^„ÄÅ„ÄÇ]*?„Å®„ÅîÈ£Ø/g, "$1");
  n = n.replace(/(„Çµ„É≥„Éâ[„Ç§„Ç£]„ÉÉ„ÉÅ|„Éà„Éº„Çπ„Éà)[^„ÄÅ„ÄÇ]*?„Å®„ÅîÈ£Ø/g, "$1");
  
  return n;
}

const splitTokens = (s) =>
  String(s || "")
    .replace(/[Ôºà(Ôºâ)Ôºª\]ÔΩõÔΩù„Äê„Äë]/g, " ")
    .replace(/[Ôºö:Ôºè/]/g, " ")
    .split(/(?:„Å®|„ÅÆ|„Éª|„ÄÅ|,|\s+)/)
    .filter(Boolean);

/* ===========================
   ÈáçË§áÂõûÈÅøÔºàÂêåÊó•„ÉªÂâçÊó•Ôºâ + ËøëÁ∏ÅÁΩÆÊèõ
=========================== */
function getReplacement(tok) {
  const pool = {
    ...ingredientCategories.meats,
    ...ingredientCategories.fish,
    ...ingredientCategories.vegetables,
    ...ingredientCategories.protein
  };
  const base = pool[canon(tok)];
  if (base?.length) {
    return base[Math.floor(Math.random() * base.length)];
  }
  const fallbacks = ["„Åª„ÅÜ„Çå„ÇìËçâ", "Â∞èÊùæËèú", "ÁôΩËèú", "È∂èËÇâ", "Ë±öËÇâ", "ÈÆ≠", "Ë±ÜËÖê"];
  return fallbacks[Math.floor(Math.random() * fallbacks.length)];
}

function filterMenu(menu) {
  if (!Array.isArray(menu) || menu.length === 0) return menu;
  
  let prevDaySet = new Set();

  return menu.map(day => {
    const usedToday = new Set();
    const mealsOut = {};

    for (const [meal, raw] of Object.entries(day.meals || {})) {
      let dish = String(raw || "");
      dish = sanitizeMeal(dish, meal);

      for (const t0 of splitTokens(dish)) {
        const t = canon(t0);
        
        if (stapleFoods.some(k => t.includes(k))) continue;
        
        if (usedToday.has(t) || prevDaySet.has(t)) {
          const rep = getReplacement(t);
          if (rep && rep !== t) {
            dish = dish.replace(new RegExp(escapeReg(t0), "g"), rep);
            usedToday.add(canon(rep));
          }
        } else {
          usedToday.add(t);
        }
      }
      mealsOut[meal] = dish;
    }

    prevDaySet = new Set(
      [...usedToday].filter(t => !stapleFoods.some(k => t.includes(k)))
    );

    return { ...day, meals: mealsOut };
  });
}

/* ===========================
   È£üÊùê„Ç´„ÉÜ„Ç¥„É™„Éû„ÉÉ„ÉóÔºàË≤∑„ÅÑÁâ©Áî®Ôºâ
=========================== */
const ingredientToCategory = (() => {
  const map = {};
  Object.keys(ingredientCategories.vegetables).forEach(k => (map[k] = "ÈáéËèú„ÉªÊûúÁâ©"));
  ["È∂èËÇâ","Ë±öËÇâ","ÁâõËÇâ","„Å≤„ÅçËÇâ","Âçµ","Ë±ÜËÖê","ÂéöÊèö„Åí","Ê≤πÊèö„Åí","ÈÆ≠","ÈØñ","„Çø„É©","„Çµ„ÉØ„É©","„ÉÑ„Éä"]
    .forEach(k => (map[k] = "ËÇâ„ÉªÈ≠ö„ÉªÂçµ„Éª‰π≥Ë£ΩÂìÅ"));
  stapleFoods.forEach(k => (map[k] = "Á©ÄÁâ©„ÉªÈ∫∫È°û„Éª„Éë„É≥"));
  
  map["È∂è"] = "ËÇâ„ÉªÈ≠ö„ÉªÂçµ„Éª‰π≥Ë£ΩÂìÅ";
  map["Ë±ö"] = "ËÇâ„ÉªÈ≠ö„ÉªÂçµ„Éª‰π≥Ë£ΩÂìÅ";
  map["Áâõ"] = "ËÇâ„ÉªÈ≠ö„ÉªÂçµ„Éª‰π≥Ë£ΩÂìÅ";
  map["„Çµ„Éº„É¢„É≥"] = "ËÇâ„ÉªÈ≠ö„ÉªÂçµ„Éª‰π≥Ë£ΩÂìÅ";
  map["„Çµ„Éê"] = "ËÇâ„ÉªÈ≠ö„ÉªÂçµ„Éª‰π≥Ë£ΩÂìÅ";
  map["„Åï„Å∞"] = "ËÇâ„ÉªÈ≠ö„ÉªÂçµ„Éª‰π≥Ë£ΩÂìÅ";
  
  return map;
})();

/* ===========================
   ÊñôÁêÜÂêç„Åã„ÇâÊó¢Áü•È£üÊùê„ÇíÊ§úÂá∫
=========================== */
const BOUNDARY = "[^\\u4E00-\\u9FFF\\u3040-\\u309F\\u30A0-\\u30FFA-Za-z0-9]";

function detectCoreIngredients(name = "") {
  const src = String(name || "");
  const found = new Set();

  const keys = new Set([
    ...Object.keys(ingredientToCategory),
    ...stapleFoods,
    ...Object.keys(aliases),
    "È∂è","Ë±ö","Áâõ","Âçµ","Ë±ÜËÖê","ÂéöÊèö„Åí","Ê≤πÊèö„Åí","ÈÆ≠","ÈØñ","„Çø„É©","„Çµ„ÉØ„É©","„ÉÑ„Éä",
  ]);

  const sortedKeys = [...keys].sort((a, b) => b.length - a.length);

  for (const k of sortedKeys) {
    if (!k) continue;
    
    if (k.length === 1) {
      const rx = new RegExp(`(?:^|${BOUNDARY})${escapeReg(k)}(?:$|${BOUNDARY})`, "u");
      if (rx.test(src)) found.add(canon(k));
    } else {
      if (src.includes(k)) found.add(canon(k));
    }
  }

  if (src.includes("Áâõ‰π≥")) found.delete("ÁâõËÇâ");
  if (src.includes("È∂è„Ç¨„É©")) found.delete("È∂èËÇâ");
  if (src.includes("Ë±öÈ™®")) found.delete("Ë±öËÇâ");

  return [...found];
}

/* ===========================
   Ë≤∑„ÅÑÁâ©„É™„Çπ„Éà„É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£
=========================== */
function stripAvailableFromShoppingList(shoppingList, availableList) {
  if (!shoppingList) return {};
  
  const avail = new Set(
    (availableList || [])
      .map(x => normalize(x))
      .filter(Boolean)
      .filter(x => x.length >= 2)
  );
  
  console.log("üîç Èô§Â§ñ„Åô„ÇãÈ£üÊùêÔºàÊ≠£Ë¶èÂåñÂæåÔºâ:", [...avail]);
  
  const out = {};
  let removedCount = 0;
  
  for (const [cat, items] of Object.entries(shoppingList)) {
    out[cat] = (items || []).filter(x => {
      const n = normalize(x);
      
      if (avail.has(n)) {
        removedCount++;
        console.log(`  ‚ùå Èô§Â§ñ: ${x} (ÂÆåÂÖ®‰∏ÄËá¥)`);
        return false;
      }
      
      for (const a of avail) {
        if (a && (n.includes(a) || a.includes(n))) {
          removedCount++;
          console.log(`  ‚ùå Èô§Â§ñ: ${x} (ÈÉ®ÂàÜ‰∏ÄËá¥: ${a})`);
          return false;
        }
      }
      
      return true;
    });
  }
  
  console.log(`üìä ${removedCount}ÂÄã„ÅÆÈ£üÊùê„ÇíË≤∑„ÅÑÁâ©„É™„Çπ„Éà„Åã„ÇâÈô§Â§ñ„Åó„Åæ„Åó„Åü`);
  
  return out;
}

function pickStapleFrom(token = "") {
  return stapleFoods.find(k => token.includes(k)) || null;
}

function normalizeProteinToken(token = "") {
  if (/È∂è|„ÉÅ„Ç≠„É≥/.test(token)) return "È∂èËÇâ";
  if (/Ë±ö(?!È™®)/.test(token)) return "Ë±öËÇâ";
  if (/Áâõ(?!‰π≥)/.test(token)) return "ÁâõËÇâ";
  if (/ÈÆ≠|„Çµ„Éº„É¢„É≥/.test(token)) return "ÈÆ≠";
  if (/ÈØñ|„Çµ„Éê|„Åï„Å∞/.test(token)) return "ÈØñ";
  if (/„Çø„É©/.test(token)) return "„Çø„É©";
  if (/„Çµ„ÉØ„É©/.test(token)) return "„Çµ„ÉØ„É©";
  if (/„ÉÑ„Éä/.test(token)) return "„ÉÑ„Éä";
  if (/Âçµ|ÁéâÂ≠ê/.test(token)) return "Âçµ";
  if (/Ë±ÜËÖê/.test(token)) return "Ë±ÜËÖê";
  if (/ÂéöÊèö„Åí/.test(token)) return "ÂéöÊèö„Åí";
  if (/Ê≤πÊèö„Åí/.test(token)) return "Ê≤πÊèö„Åí";
  return null;
}

function ensureShoppingFromMenu(menu = [], shopping = {}) {
  const cats = ["ÈáéËèú„ÉªÊûúÁâ©","ËÇâ„ÉªÈ≠ö„ÉªÂçµ„Éª‰π≥Ë£ΩÂìÅ","Á©ÄÁâ©„ÉªÈ∫∫È°û„Éª„Éë„É≥","Ë™øÂë≥Êñô„ÉªÊ≤π","„Åù„ÅÆ‰ªñ"];
  cats.forEach(c => (shopping[c] = Array.isArray(shopping[c]) ? shopping[c] : []));
  
  const seen = {};
  cats.forEach(c => (seen[c] = new Set((shopping[c] || []).map(x => x.trim().toLowerCase()))));

  for (const day of (menu || [])) {
    for (const meal of ["ÊúùÈ£ü","ÊòºÈ£ü","Â§ïÈ£ü"]) {
      const name = String(day?.meals?.[meal] || "");
      const toks = new Set(splitTokens(name));
      detectCoreIngredients(name).forEach(t => toks.add(t));

      for (let t0 of toks) {
        let t = canon(t0);
        let cat = ingredientToCategory[t];

        if (!cat) {
          const staple = pickStapleFrom(t);
          if (staple) {
            t = staple;
            cat = "Á©ÄÁâ©„ÉªÈ∫∫È°û„Éª„Éë„É≥";
          } else {
            const prot = normalizeProteinToken(t);
            if (prot) {
              t = prot;
              cat = "ËÇâ„ÉªÈ≠ö„ÉªÂçµ„Éª‰π≥Ë£ΩÂìÅ";
            }
          }
        }

        if (cat && !seen[cat].has(t.toLowerCase())) {
          shopping[cat].push(t);
          seen[cat].add(t.toLowerCase());
        }
      }
    }
  }
  
  return shopping;
}

/* ===========================
   „Éó„É≠„É≥„Éó„Éà
=========================== */
function buildPrompt({ toddlers, kids, adults, days, meals = [], avoid, request, available, avoidRecent = [] }) {
  const mealsLine = meals.length ? meals.join("„ÄÅ") : "ÊúùÈ£ü„ÄÅÊòºÈ£ü„ÄÅÂ§ïÈ£ü";
  const avoidLine = [avoid, ...(avoidRecent || [])].filter(Boolean).join("„ÄÅ") || "„Å™„Åó";

  const fields = [];
  if (meals.includes("ÊúùÈ£ü")) fields.push(`"ÊúùÈ£ü": "ÊñôÁêÜÂêç"`);
  if (meals.includes("ÊòºÈ£ü")) fields.push(`"ÊòºÈ£ü": "ÊñôÁêÜÂêç"`);
  if (meals.includes("Â§ïÈ£ü")) fields.push(`"Â§ïÈ£ü": "ÊñôÁêÜÂêç"`);

  return `
Âé≥ÂØÜJSON„ÅÆ„Åø„ÇíËøî„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºàË™¨Êòé„Éª„Ç≥„Éº„Éâ„Éï„Çß„É≥„ÇπÁ¶ÅÊ≠¢Ôºâ„ÄÇÂøÖ„Åö "menu" „ÅÆË¶ÅÁ¥†Êï∞„ÅØ ${days} ‰ª∂„ÄÅ"day" „ÅØ 1..${days} „ÅÆÈÄ£Áï™„ÄÇ

ÂÆ∂Êóè: ÂπºÂÖê${toddlers} / Â∞èÂ≠¶Áîü${kids} / Â§ß‰∫∫${adults}
Êó•Êï∞: ${days}
Âá∫Âäõ„Åô„ÇãÈ£ü‰∫ã: ${mealsLine}ÔºàÊú™ÈÅ∏Êäû„ÅÆÈ£ü‰∫ã„ÅØÂá∫Âäõ„Åó„Å™„ÅÑÔºâ
ÈÅø„Åë„Åü„ÅÑË™û„ÇÑÊñôÁêÜ: ${avoidLine}
„É™„ÇØ„Ç®„Çπ„Éà: ${request || "„Å™„Åó"}
ÂÆ∂„Å´„ÅÇ„ÇãÈ£üÊùê: ${available || "„Å™„Åó"}

Âà∂Á¥Ñ:
- ÊñôÁêÜÂêç„ÅØÂêçË©û1Ë™û„ÅÆ„ÅøÁ¶ÅÊ≠¢ÔºàÂøÖ„ÅöË™øÁêÜÊ≥ï/„Çπ„Çø„Ç§„É´„ÇíÂê´„ÇÄÔºâ
- ÊòºÈ£ü„ÅØ‰∏ªÈ£üÔºà„ÅîÈ£Ø/„Éë„É≥/È∫∫Ôºâ„ÇíÂøÖ„ÅöÂê´„ÇÄ
- Â§ïÈ£ü„ÅØ‰∏ªËèúÔºàËÇâ/È≠ö/Âçµ/Ë±ÜËÖêÁ≠âÔºâ„ÇíÂøÖ„ÅöÂê´„ÇÄ„ÄÅ„Çµ„É©„ÉÄÂçòÂìÅÁ¶ÅÊ≠¢
- Âêå„Åò‰∏ªË¶Å„Åü„Çì„Å±„ÅèË≥™ÔºàÈ∂è/Ë±ö/Áâõ/ÈÆ≠/ÈØñ/„Çø„É©/Âçµ/Ë±ÜËÖê/„ÉÑ„ÉäÔºâ„ÇíÂêå„ÅòÊó•„Å´ÈáçË§á„Åï„Åõ„Å™„ÅÑ
- Âë≥ÂôåÊ±Å/„Çπ„Éº„Éó„ÅÆÂÖ∑„ÅØÈáéËèú„Éª„Åç„ÅÆ„Åì„ÉªË±ÜËÖê„Éª„Çè„Åã„ÇÅÁ≠â„ÅÆ„Åø

{
  "menu":[
    ${Array.from({ length: Number(days) || 1 }, (_, i) => `{"day":${i + 1},"meals":{ ${fields.join(", ")} },"nutrition":{"kcal":0,"protein_g":0,"veg_servings":0,"balance":""}}`).join(",")}
  ],
  "shoppingList":{"ÈáéËèú„ÉªÊûúÁâ©":[],"ËÇâ„ÉªÈ≠ö„ÉªÂçµ„Éª‰π≥Ë£ΩÂìÅ":[],"Á©ÄÁâ©„ÉªÈ∫∫È°û„Éª„Éë„É≥":[],"Ë™øÂë≥Êñô„ÉªÊ≤π":[],"„Åù„ÅÆ‰ªñ":[]},
  "availableList":[]
}`.trim();
}

/* ===========================
   „Éê„É™„Éá„Éº„Ç∑„Éß„É≥
=========================== */
function validateMenuRequest(body) {
  const { toddlers, kids, adults, days, meals } = body;
  
  const errors = [];
  
  if (!Number.isInteger(toddlers) || toddlers < 0 || toddlers > 10) {
    errors.push("ÂπºÂÖê„ÅÆ‰∫∫Êï∞„ÅØ0„Äú10„ÅÆÊï¥Êï∞„ÅßÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ");
  }
  if (!Number.isInteger(kids) || kids < 0 || kids > 10) {
    errors.push("Â∞èÂ≠¶Áîü„ÅÆ‰∫∫Êï∞„ÅØ0„Äú10„ÅÆÊï¥Êï∞„ÅßÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ");
  }
  if (!Number.isInteger(adults) || adults < 0 || adults > 10) {
    errors.push("Â§ß‰∫∫„ÅÆ‰∫∫Êï∞„ÅØ0„Äú10„ÅÆÊï¥Êï∞„ÅßÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ");
  }
  if (!Number.isInteger(days) || days < 1 || days > 14) {
    errors.push("Êó•Êï∞„ÅØ1„Äú14„ÅÆÊï¥Êï∞„ÅßÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ");
  }
  if (!Array.isArray(meals) || meals.length === 0) {
    errors.push("Â∞ë„Å™„Åè„Å®„ÇÇ1„Å§„ÅÆÈ£ü‰∫ã„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ");
  }
  
  return errors;
}

/* ===========================
   API: ÁåÆÁ´ãÁîüÊàê
=========================== */
app.post("/generate-menu", async (req, res, next) => {
  try {
    console.log("üìù ÁåÆÁ´ãÁîüÊàê„É™„ÇØ„Ç®„Çπ„ÉàÂèó‰ø°");
    
    const validationErrors = validateMenuRequest(req.body);
    if (validationErrors.length > 0) {
      return res.status(400).json({
        error: "validation_error",
        details: validationErrors
      });
    }
    
    const {
      toddlers,
      kids,
      adults,
      days,
      meals = [],
      avoid,
      request,
      available,
      avoidRecent = []
    } = req.body;

    const availableList = String(available || "")
      .split(/[„ÄÅ,]/)
      .map(s => s.trim())
      .filter(Boolean);
    
    console.log("üì¶ ÂÆ∂„Å´„ÅÇ„ÇãÈ£üÊùê:", availableList);

    const prompt = buildPrompt({
      toddlers,
      kids,
      adults,
      days,
      meals,
      avoid,
      request,
      available: availableList.join('„ÄÅ'),
      avoidRecent
    });

    let content = await callModel(prompt, { temperature: 0.7 });
    let raw = extractFirstJson(content);
    let json;
    
    try {
      json = JSON.parse(raw);
    } catch (parseError) {
      console.warn("‚ö†Ô∏è ÂàùÂõûJSON„Éë„Éº„ÇπÂ§±Êïó„ÄÅ„É™„Éà„É©„Ç§„Åó„Åæ„Åô");
      const retry = prompt + "\n\n„ÄêÈáçË¶Å„ÄëJSON‰ª•Â§ñ„ÅØÂá∫Âäõ„Åó„Å™„ÅÑ„ÄÇ";
      content = await callModel(retry, { temperature: 0.4 });
      raw = extractFirstJson(content);
      json = JSON.parse(raw);
    }

    json.menu = (json.menu || []).map(d => {
      const n = d.nutrition || {};
      return {
        ...d,
        nutrition: {
          kcal: Number.isFinite(n.kcal) ? n.kcal : 0,
          protein_g: Number.isFinite(n.protein_g) ? n.protein_g : 0,
          veg_servings: Number.isFinite(n.veg_servings) ? n.veg_servings : 0,
          balance: typeof n.balance === "string" ? n.balance : ""
        }
      };
    });

    json.menu = (json.menu || []).map(d => {
      const out = { ...d, meals: { ...(d.meals || {}) } };
      ["ÊúùÈ£ü","ÊòºÈ£ü","Â§ïÈ£ü"].forEach(m => {
        if (out.meals[m] != null) {
          out.meals[m] = sanitizeMeal(String(out.meals[m] || ""), m);
        }
      });
      return out;
    });

    json.menu = filterMenu(json.menu);

    json.availableList = availableList;
    
    console.log("üì¶ Ë®≠ÂÆö„Åï„Çå„ÅüavailableList:", json.availableList);

    json.shoppingList = stripAvailableFromShoppingList(
      json.shoppingList || {},
      availableList
    );
    
    json.shoppingList = ensureShoppingFromMenu(json.menu, json.shoppingList);
    
    json.shoppingList = stripAvailableFromShoppingList(
      json.shoppingList,
      availableList
    );

    const cats = ["ÈáéËèú„ÉªÊûúÁâ©","ËÇâ„ÉªÈ≠ö„ÉªÂçµ„Éª‰π≥Ë£ΩÂìÅ","Á©ÄÁâ©„ÉªÈ∫∫È°û„Éª„Éë„É≥","Ë™øÂë≥Êñô„ÉªÊ≤π","„Åù„ÅÆ‰ªñ"];
    for (const c of cats) {
      const arr = Array.isArray(json.shoppingList[c]) ? json.shoppingList[c] : [];
      json.shoppingList[c] = [...new Set(arr.map(s => s.trim()).filter(Boolean))];
      json.shoppingList[c].sort((a, b) => a.localeCompare(b, 'ja'));
    }

    console.log("‚úÖ Ë≤∑„ÅÑÁâ©„É™„Çπ„ÉàÁîüÊàêÂÆå‰∫Ü");
    console.log("   „Ç´„ÉÜ„Ç¥„É™Âà•„Ç¢„Ç§„ÉÜ„É†Êï∞:", 
      Object.fromEntries(cats.map(c => [c, json.shoppingList[c].length]))
    );

    res.json(json);
    
  } catch (e) {
    console.error("‚ùå ÁåÆÁ´ãÁîüÊàê„Ç®„É©„Éº:", e);
    next(e);
  }
});

/* ===========================
   API: „É¨„Ç∑„ÉîÁîüÊàê
=========================== */
app.post("/generate-recipe", async (req, res, next) => {
  try {
    const { dish, toddlers = 0, kids = 0, adults = 2, mode = "standard" } = req.body;
    const portions = Number(adults) + Number(kids) * 0.7 + Number(toddlers) * 0.5;
    const servings = Math.max(2, Math.round(portions));

    const cleanDish = (name = "") =>
      String(name).replace(/[‚Ä¢‚óè„Éª\-]/g, "").replace(/\s+/g, " ").replace(/^\s*„Éª?\s*/, "").trim();
    const normalizeDish = (name = "") => {
      let n = cleanDish(name) || "È∂è„ÅÆÁÖß„ÇäÁÑº„Åç";
      if (/^(Ë±ÜËÖê)$/i.test(n)) n = "Ë±ÜËÖê„Çπ„ÉÜ„Éº„Ç≠";
      if (/^(„Çµ„É©„ÉÄ)$/i.test(n)) n = "„ÉÅ„Ç≠„É≥„Çµ„É©„ÉÄ";
      if (/^(Âçµ|Á¥çË±Ü)$/i.test(n)) n = `${n}„ÉÅ„É£„Éº„Éè„É≥`;
      if (/„Çµ„É©„ÉÄ$/.test(n) && !/(„Çµ„É≥„Éâ|‰∏º|ÂÆöÈ£ü|„Éë„Çπ„Çø|„ÅÜ„Å©„Çì|„Åù„Å∞|„É©„Éº„É°„É≥|„ÅîÈ£Ø|„É©„Ç§„Çπ)/.test(n)) n = n.replace(/„Çµ„É©„ÉÄ$/, "„Çµ„É©„ÉÄ„Çµ„É≥„Éâ");
      return n;
    };
    const safeDish = normalizeDish(dish);

    const prompt = `
Êó•Êú¨„ÅÆÂÆ∂Â∫≠ÊñôÁêÜ„ÅÆ„É¨„Ç∑„Éî„ÇíÂé≥ÂØÜJSON„ÅßËøî„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇË™¨ÊòéÁ¶ÅÊ≠¢„ÄÇ

„ÄêÊñôÁêÜÂêç„Äë${safeDish}
„ÄêÂàÜÈáè„ÄëÁ¥Ñ${servings}‰∫∫Ââç
„Äê„É¢„Éº„Éâ„Äë${mode === "economy" ? "ÁØÄÁ¥Ñ" : mode === "quick" ? "ÊôÇÁü≠" : "Ê®ôÊ∫ñ"}

{
  "title": "ÊñôÁêÜÂêç",
  "servings": ${servings},
  "ingredients": ["ÂÖ∑‰ΩìÈ£üÊùê Èáè", "..."],
  "seasonings": ["Ë™øÂë≥Êñô Èáè", "..."],
  "steps": ["ÊâãÈ†Ü1", "..."],
  "tips": ["„Ç≥„ÉÑ1", "..."],
  "nutrition_per_serving": { "kcal": 0, "protein_g": 0 }
}`.trim();

    let content = await callModel(prompt, { temperature: 0.6 });
    let raw = extractFirstJson(content);
    let json;
    
    try {
      json = JSON.parse(raw);
    } catch {
      const retry = prompt + "\n\n„ÄêÈáçË¶Å„ÄëJSON„ÅÆ„Åø„ÇíÂé≥ÂØÜ„Å´Âá∫Âäõ„ÄÇ";
      content = await callModel(retry, { temperature: 0.3 });
      raw = extractFirstJson(content);
      json = JSON.parse(raw);
    }

    res.json(json);
  } catch (e) {
    console.error("„É¨„Ç∑„ÉîÁîüÊàê„Ç®„É©„Éº:", e);
    next(e);
  }
});

/* ===========================
   API: Ë≤∑„ÅÑÁâ©„É™„Çπ„ÉàÂÜçË®àÁÆó
=========================== */
app.post("/recalc-shopping", async (req, res, next) => {
  try {
    console.log("üîÑ Ë≤∑„ÅÑÁâ©„É™„Çπ„ÉàÂÜçË®àÁÆó„É™„ÇØ„Ç®„Çπ„Éà");
    
    const { menu = [], available = "" } = req.body;
    
    const availableList = String(available)
      .split(/[„ÄÅ,]/)
      .map(s => s.trim())
      .filter(Boolean);
    
    console.log("üì¶ ÂÆ∂„Å´„ÅÇ„ÇãÈ£üÊùê:", availableList);

    let shopping = ensureShoppingFromMenu(menu, {});
    
    shopping = stripAvailableFromShoppingList(shopping, availableList);

    const cats = ["ÈáéËèú„ÉªÊûúÁâ©","ËÇâ„ÉªÈ≠ö„ÉªÂçµ„Éª‰π≥Ë£ΩÂìÅ","Á©ÄÁâ©„ÉªÈ∫∫È°û„Éª„Éë„É≥","Ë™øÂë≥Êñô„ÉªÊ≤π","„Åù„ÅÆ‰ªñ"];
    for (const c of cats) {
      const arr = Array.isArray(shopping[c]) ? shopping[c] : [];
      shopping[c] = [...new Set(arr.map(s => s.trim()).filter(Boolean))];
      shopping[c].sort((a, b) => a.localeCompare(b, 'ja'));
    }
    
    console.log("‚úÖ Ë≤∑„ÅÑÁâ©„É™„Çπ„ÉàÂÜçË®àÁÆóÂÆå‰∫Ü");
    console.log("   „Ç´„ÉÜ„Ç¥„É™Âà•„Ç¢„Ç§„ÉÜ„É†Êï∞:", 
      Object.fromEntries(cats.map(c => [c, shopping[c].length]))
    );
    
    res.json({ 
      shoppingList: shopping, 
      availableList: availableList 
    });
    
  } catch (e) {
    console.error("‚ùå Ë≤∑„ÅÑÁâ©„É™„Çπ„ÉàÂÜçË®àÁÆó„Ç®„É©„Éº:", e);
    next(e);
  }
});

/* ===========================
   „Ç®„É©„Éº„Éè„É≥„Éâ„É©
=========================== */
app.use((err, req, res, next) => {
  if (res.headersSent) return next(err);
  console.error("üí• Unhandled error:", err);
  res.status(500).json({ 
    error: "internal_error", 
    detail: String(err?.message || err) 
  });
});
/* ===========================
   API: ÂçòÂìÅ„É¨„Ç∑„ÉîÊèêÊ°àÔºàrecipe.htmlÁî®Ôºâ
=========================== */
app.post("/recipe", async (req, res, next) => {
  try {
    console.log("üç≥ „É¨„Ç∑„ÉîÊèêÊ°à„É™„ÇØ„Ç®„Çπ„ÉàÂèó‰ø°");
    
    const {
      ingredients,
      useIn = [],
      toddlers = 0,
      kids = 0,
      adults = 2,
      wantKidsMenu = "„ÅÑ„ÅÑ„Åà",
      genre = "",
      request = "",
      avoid = "",
      menuType = "recipe",
      mainDish = false,
      sideDish = false,
      soup = false
    } = req.body;

    const portions = Number(adults) + Number(kids) * 0.7 + Number(toddlers) * 0.5;
    const servings = Math.max(2, Math.round(portions));

    let prompt = "";

    if (menuType === "menu") {
      // 1È£ü„ÅÆÁåÆÁ´ã
      prompt = `
„Äê1È£üÂàÜ„ÅÆÁåÆÁ´ãÊèêÊ°à„Äë
È£üÊùê: ${ingredients}
‰∫∫Êï∞: ÂπºÂÖê${toddlers}‰∫∫„ÄÅÂ∞èÂ≠¶Áîü${kids}‰∫∫„ÄÅÂ§ß‰∫∫${adults}‰∫∫
Â≠ê„Å©„ÇÇÂêë„Åë: ${wantKidsMenu}
„Ç∏„É£„É≥„É´: ${genre || "ÊåáÂÆö„Å™„Åó"}
Ë¶ÅÊúõ: ${request || "„Å™„Åó"}
ÈÅø„Åë„Åü„ÅÑ: ${avoid || "„Å™„Åó"}

‰∏ªËèú„ÉªÂâØËèú„ÉªÊ±ÅÁâ©„ÅÆ„Éê„É©„É≥„Çπ„ÅÆÂèñ„Çå„Åü1È£üÂàÜ„ÅÆÁåÆÁ´ã„ÇíÊèêÊ°à„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
ÂêÑÊñôÁêÜ„ÅÆÁ∞°Âçò„Å™‰Ωú„ÇäÊñπ„ÇÇÂê´„ÇÅ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

„ÄêÂá∫ÂäõÂΩ¢Âºè„Äë
‚ñ† ‰∏ªËèú: ÊñôÁêÜÂêç
ÊùêÊñô: ...
‰Ωú„ÇäÊñπ: ...

‚ñ† ÂâØËèú: ÊñôÁêÜÂêç
ÊùêÊñô: ...
‰Ωú„ÇäÊñπ: ...

‚ñ† Ê±ÅÁâ©: ÊñôÁêÜÂêç
ÊùêÊñô: ...
‰Ωú„ÇäÊñπ: ...
`.trim();

    } else {
      // ÂçòÂìÅ„É¨„Ç∑„Éî
      const useInText = useIn.length > 0 
        ? `Ôºà${useIn.map(x => x === 'main' ? '‰∏ªËèú' : x === 'side' ? 'ÂâØËèú' : 'Ê±ÅÁâ©').join('„Éª')}„Åß‰ΩøÁî®Ôºâ` 
        : '';
      
      prompt = `
„Äê„É¨„Ç∑„ÉîÊèêÊ°à„Äë
È£üÊùê: ${ingredients} ${useInText}
‰∫∫Êï∞: Á¥Ñ${servings}‰∫∫Ââç
Â≠ê„Å©„ÇÇÂêë„Åë: ${wantKidsMenu}
„Ç∏„É£„É≥„É´: ${genre || "ÊåáÂÆö„Å™„Åó"}
Ë¶ÅÊúõ: ${request || "„Å™„Åó"}
ÈÅø„Åë„Åü„ÅÑ: ${avoid || "„Å™„Åó"}

‰∏äË®ò„ÅÆÈ£üÊùê„Çí‰Ωø„Å£„Åü${servings}‰∫∫Ââç„ÅÆ„É¨„Ç∑„Éî„Çí1„Å§ÊèêÊ°à„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

„ÄêÂá∫ÂäõÂΩ¢Âºè„Äë
‚ñ† ÊñôÁêÜÂêç: ‚óã‚óã‚óã‚óã

‚ñ† ÊùêÊñôÔºà${servings}‰∫∫ÂâçÔºâ
- È£üÊùêÂêç: ÂàÜÈáè
- ...

‚ñ† ‰Ωú„ÇäÊñπ
1. ÊâãÈ†Ü1
2. ÊâãÈ†Ü2
...

‚ñ† „Éù„Ç§„É≥„Éà
- „Ç≥„ÉÑ„ÇÑ„Ç¢„É¨„É≥„Ç∏Ê°à
`.trim();
    }

    const content = await callModel(prompt, { temperature: 0.7 });
    
    console.log("‚úÖ „É¨„Ç∑„ÉîÊèêÊ°àÁîüÊàêÂÆå‰∫Ü");
    
    res.json({ recipe: content });
    
  } catch (e) {
    console.error("‚ùå „É¨„Ç∑„ÉîÊèêÊ°à„Ç®„É©„Éº:", e);
    next(e);
  }
});

/* ===========================
   „Çµ„Éº„Éê„ÉºËµ∑Âãï
=========================== */
app.listen(port, () => {
  console.log(`‚úÖ Server running on http://localhost:${port}`);
  console.log(`   Environment: ${process.env.NODE_ENV || 'development'}`);
  console.log(`   OpenAI API: ${process.env.OPENAI_API_KEY ? '‚úì Configured' : '‚úó Missing'}`);
});
